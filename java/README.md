# Quiz

## CH6 객체 지향 프로그래밍 Ⅰ

<details>
<summary>
객체지향언어의 장점
</summary>

---

코드의 재사용성이 높으며, 관리가 용이하고(적은 노력으로 쉽게 코드를 변경할 수 있음), 신뢰성이 높은 프로그래밍을 가능하게 한다(캡슐화)

---

</details>

<details>
<summary>
클래스의 정의와 용도가 무엇인가?
</summary>

---

클래스의 정의는 객체를 정의해 놓은 것으로 객체의 설계도 또는 틀이라고도 할 수 있으며, 객체를 생성하는데 사용된다.

---

</details>

<details>
<summary>
객체란 무엇인가?
</summary>

---

프로그래밍에서 객체란 클래스에 정의된 내용대로 **메모리**에 생성된 것을 말한다.

---

</details>


<details>
<summary>
클래스를 정의하는 이유
</summary>

---

한번 정의해 놓으면 매번 객체를 생성할 때마다 어떻게 만들어야할지 고민하지 않아도 된다.(붕어빵 틀, 설계도)

---

</details>

<details>
<summary>
인스턴스, 인스턴스화란 무엇인가
</summary>

----

클래스로 부터 만들어진 객체를 **인스턴스**라고 부르며, 그 과정을 **인스턴스화**라고 부른다.

----

</details>

<details>
<summary>
객체의 구성요소 2가지
</summary>

----

속성과 기능

```java
class Tv{
    boolean power; // 속성
    
    void power(); // 기능
}
```

----

</details>

<details>
<summary>
자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 어떻게 되는가
</summary>

----

가비지 컬렉터에 의해서 자동적으로 메모리에서 제거가 된다.

----

</details>

<details>
<summary>
변수, 배열, 구조체, 클래스의 프로그래밍적인 관점에서의 정의 
</summary>

----

1. 변수 : 하나의 데이터를 저장할 수 있는 공간

2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간

3. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간

4. 클래스 : 데이터와 함수의 결합(구조체 + 함수)

----

</details>

<details>
<summary>
변수의 종류의 3가지와 종류를 결정짓는 중요한 요소는?
</summary>

---

클래스 변수, 인스턴스 변수, 지역 변수 이렇게 3가지로 분류가 되며 결정짓는 요소는 
변수의 선언된 위치이다. 클래스 변수와 인스턴스 변수는 모두 멤버 변수에 속한다.
멤버 변수에 static이 붙었다면 클래스 변수, 그렇지 않다면 인스턴스 변수이다.

```java
class Variables{
    int iv; // 인스턴스 변수 (멤버 변수)
    static int cv; // 클래스 변수 (멤버 변수)
    
    void method(){
        int lv = 0; // 지역변수
    }
}
```

---

</details>

<details>
<summary>
클래스 변수와 인스턴스 변수의 차이점에 대해 설명
</summary>

----

인스턴스 변수는 인스턴스마다 독립적인 공간을 가지므로 인스턴스 마다 고유한 상태를 유지해야하는 속성의 경우 인스턴스 변수로 선언하고
모든 인스턴스가 공통된 값을 유지해야하는 속성의 경우 클래스 변수로 선언해야 한다.

또한 클래스 변수의 경우 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있으며 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 유지되며
public을 붙이는 경우 프로그램 내에서 어디서나 접근할 수 있는 전역변수의 성격을 갖는다.

----

</details>

<details>
<summary>
메서드를 사용하는 이유 3가지와 이에 대해 설명
</summary>

----

높은 재사용성 : 한번 만들어놓은 메서드는 몇 번이고 호출할 수 있으며, 다른 프로그램에서도 사용이 가능하다. ex) JAVA API

중복된 코드의 제거 : 프로그램을 작성하다보면, 작은 태용의 문장들이 여러 곳에 반복해서 나타나곤 하는데, 이런 반복을 줄임으로써 코드의 길이를 줄이고 변경사항이 발생했을 때 수정해야할 코드의 양을 줄여 오류가 발생할 가능성도 함께 줄어든다.

프로그램의 구조화 : 큰 규모의 프로그램에서는 문장을 작업단위로 나눠서 열 개의 메서드에 담아 프로그램의 구조를 단순화 시키는 것이 필수적이다.

----
</details>

<details>
<summary>
JVM의 메모리 구조에 대해 설명
</summary>

응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고
JVM은 메모리를 용도에 따라 3가지 영역으로 나누어 관리한다. 
----

### 메서드 영역
프로그램 실행 중 어떤 클래스가 사용되면 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.
### 힙 영역
인스턴스가 생성되는 공간
### 스택 영역
메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간 결과 등을 저장하는데 사용

----
</details>

<details>
<summary>
기본형 매개변수와 참조형 매개변수의 차이
</summary>

----

기본형 매개변수는 값을 읽기만 할 수 있지만 참조형 매개변수는 읽기, 쓰기 모두 가능하다.

````java
class Ex{
    static class Data{
        int x;
    }
    static void ex1(int x){ // 기본형 매개변수
        System.out.print(x);
    }
    static void ex2(Data data){ // 참조형 매개변수
        data.x = 100;
        System.out.println(data.x);
    }
}
````

----
</details>

<details>
<summary>
인스턴스 메서드와 클래스 메서드의 차이와 언제 클래스 메서드를 사용해야 하는지, 클래스 메서드를 사용하면 좋은 점을 설명
</summary>

----

1. 변수와 마찬가지로 static 이 붙으면 클래스 메서드, 아니면 인스턴스 메서드이다.
2. 인스턴스 메서드와 달리 클래스 메서드는 인스턴스를 생성하지 않아도 호출이 가능하다. (그래서 클래스 메서드에서 인스턴스 변수 사용을 금지한다.)

클래스 메서드의 장점은 아래와 같다.

- 성능 면에서 더 좋음

인스턴스 변수와 인스텬스 메서드를 사용하지 않는 메서드의 경우 static 을 붙여서 클래스 메서드로 사용하는 것이 성능 면에서 더 좋다.
인스턴스 메서드의 경우 실행 시 호출 되어야할 메서드를 찾는 과정이 추가적으로 들어가기 때문에 시간이 더 걸리기 때문이다.

----
</details>

<details>
<summary>
클래스 멤버가 인스턴스 멤버를 참조 또는 호출해야 할 경우 반드시 해야하는 것
</summary>

----

앞서 인스턴스를 생성해야 한다.

````java
class Ex{
    int num = 1;
    static int num2 = new Ex().num + 1; 
    
    static void staticMathod(){
        System.out.println(new Ex().num);
    }
}
````

----
</details>

<details>
<summary>
오버로딩의 조건과 장점을 설명
</summary>

----

조건
1. 같은 메서드 이름을 가져야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

장점

메서드의 **이름을 절약**할 수 있으며 **같은 기능을 하는 메서드**들을 **하나의 이름**으로 정의하여 기억하기도 쉽고 **기능을 예측**하기도 쉽다.

----
</details>

<details>
<summary>
가변 인자란 무엇이고 장점,단점은 무엇이 있는지 설명
</summary>

----

매개변수의 개수를 동적으로 지정해 줄 수 있는 기능을 말하며 매개변수의 개수를 다르게 해서 여러 개의 메서드를 작성할 때 하나로 대체할 수 있기에 편리하다.

하지만 가변인자는 내부적으로 배열로 이루저여 있기 떄문에 호출할 때마다 배열이 생기기 때문에 비효율에 주의하며 꼭 필요할 때 사용해야 하며, 가변인자를 
포함한 메서드의 경우 오버로딩하면, 구별되지 못하는 경우가 발생하기에 주의해야 한다.

----
</details>

<details>
<summary>
생성자의 정의와 역할을 설명
</summary>

----

인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드로써 

- 인스턴스 변수의 초기화 작업
- 인스턴스 생성 시에 실행되어야 할 작업

을 위해 사용된다.

----
</details>

<details>
<summary>
기본 생성자 주의사항
</summary>

----

생성자가 하나라도 존재하는 경우 생성되지 않는다.

----
</details>

<details>
<summary>
생성자에서 다른 생성자를 호출할 때의 주의사항과 장점 설명
</summary>

----

this() 를 통해 호출해야 하며, 반드시 첫줄에서만 호출이 가능하다.

장점

- 생성자에서 다른 생성자를 호출하는 방식은 코드를 유기적으로 연결하여 더 좋은 코드를 얻을 수 있으며
- 또한 수정이 필요한 경우에도 보다 적은 코드만을 변경해주면 되므로 유지보수가 쉬워진다.

추가적으로 클래스 메소드의 경우 this 키워드를 사용할 수 없다.
> 클래스 메소드의 경우 인스턴스 생성과 관련없이 호출이 가능하기 때문에 호출 시점에 인스턴스가 존재하지 않을 수 있다. 


----
</details>

<details>
<summary>
this와 this()의 차이점
</summary>

----

### this
> 인스턴스 자신을 가리키는 참조변수이며 인스턴스의 주소가 저장되어 있다.
> 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.
### this()
> 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용된다.

----
</details>


<details>
<summary>
변수의 종류
</summary>

----

멤버 변수(클래스 변수, 인스턴스 변수), 지역변수

----

</details>


<details>
<summary>
지역 변수와 멤버 변수 중 초기화 작업이 필수적인 변수는?
</summary>

----

지역 변수

멤버 변수의 경우 자동으로 자료형에 맞는 기본값으로 초기화가 된다.

----

</details>


<details>
<summary>
멤버 변수의 초기화 방법 3가지에 대해 설명
</summary>

----

멤버 변수의 초기화 방법
- 명시적 초기화
- 초기화 블럭
- 생성자

### 명시적 초기화
: 선언과 동시에 초기화 하는 것을 의미

### 생성자 초기화
: 생성자를 통해 초기화 하는 것을 의미 (인스턴스 변수)

### 초기화 블럭
: 변수의 복잡한(조건문, 반복문, 예외처리문이 들어간..) 초기화에 사용되는 방법이다.

클래스 초기화 블럭은 클래스가 메모리에 로딩 될 때 실행되고, 인스턴스 초기화 블럭의 경우 생성자에 앞서 실행되기 때문에 이를 활용하여 생성자에 공통으로 들어가는 코드를 인스턴스 블럭으로 처리하게 된다면 중복을 제거하여 좋은 코드를 작성할 수 있게 된다.

----

</details>


<details>
<summary>
인스턴스 초기화 블럭과 클래스 초기화 블럭에 차이점
</summary>

----

클래스 초기화 블럭
- 클래스가 메모리에 로딩될 때 한번 실행

인스턴스 초기화 블럭
- 인스턴스가 생성될 때마다 실행

----

</details>


<details>
<summary>
멤버 변수의 초기화 시기와 순서
</summary>

----

### 클래스 변수

- 초기화 시기 : 클래스가 처음 로딩 될 때

클래스 변수의 초기화 순서
> 기본값 -> 명시적 초기화 -> 초기화 블럭

### 인스턴스 변수

- 초기화 시기 : 인스턴스가 생성 될 때 마다

인스턴스 변수의 초기화 순서
> 기본값 -> 명시적 초기화 -> 초기화 블럭 -> 생성자

----

</details>


## CH 7 객체 지향 프로그래밍 Ⅱ

<details>
<summary>
상속의 장점을 아는대로 설명
</summary>

----

> 코드의 재사용성을 높이고 중복을 제거하여 생산성과 유지보수에 크게 기여한다.

적은 양의 코드로 새로운 클래스를 작성할 수 있으며, 코드를 공통적으로 관리할 수 있기 때문에 코드 추가 및 변경이 매우 용이하다.
이러한 특징으로 인해 코드의 재사용성을 높이고, 중복을 제거하여 생산성과 유지보수에 크게 기여한다.

----
</details>

<details>
<summary>
자손 클래스를 인스턴스화하면 어떻게 되는가
</summary>

----

조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

----
</details>

<details>
<summary>
상속 관계와 포함 관계에 대해 설명
</summary>

----

둘 다 클래스 간에 관계를 맺어 주고 클래스를 재사용하는 방법이다. 차이는 그 의미에 있다.


상속 관계의 경우 
>'A는 B이다.' 라는 의미에 적합하다. 

포함 관계의 경우
>'A는 B를 가지고 있다' 라는 의미에 좀 더 적합하다.

----
</details>

<details>
<summary>
자바가 단일 상속만을 허용하는 이유에 대해 설명
</summary>

----

다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 갖을 수는 있지만 아래와 같은 단점들이 있다.

- 클래스간의 관계가 매우 복잡해짐
- 서로 다른 클래스로부터 상속 받은 멤버의 이름이 같을 경우 구분할 수 있는 방법이 없음

때문에 클래스간의 관계를 보다 명확히 하고 코드를 더욱 신뢰할 수 있게 만들어주기 위해 단일 상속만을 허용한다.

----
</details>

<details>
<summary>
Object 클래스에 대해서 설명
</summary>

----

상속 계층도에서 가장 최상위에 위치한 클래스이며 컴파일러가 모든 클래스가 Object클래스를 상속받도록 해준다.
즉 모든 클래스에는 extends Object 라는 문구가 생략되어 있다고 봐도 무방하다.

상속 받았기에 모든 클래스는 toString(), equals() 같은 멤버들을 사용할 수 있다.

----
</details>


<details>
<summary>
super, super() 키워드에 대해서 설명
</summary>

----

super
> 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수

super()
> 조상 클래스의 생성자를 호출하는데 사용되는 키워드

둘 다 클래스 메서드에서는 사용할 수 없다.
> 클래스 멤버는 클래스 로딩 시점에 초기화 되는데 인스턴스 멤버는 인스턴스 생성 시점에 초기화된다. 따라서
> 참조 및 초기화 시점에 인스턴스 멤버가 존재하지 않을 수 있기 때문에 사용할 수 없다.

----
</details>


<details>
<summary>
생성자의 첫줄에서 조상 클래스의 생성자를 호출해야 하는 이유
</summary>

----

자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 있기 때문에 조상 클래스의 멤버들이 먼저 초기화 되어야 한다.

이것은 최상위 클래스인 Object를 제외한 모든 클래스에 해당하는 말이다.

>만약 초기화 하지 않는다면 컴파일러가 자동으로 super(); 를 추가할 것인데, 만약 조상 클래스에 디폴트 생성자가 존재하지 않는다면 컴파일 오류가 날 것이다.

----
</details>

<details>
<summary>
자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 이유
</summary>

----

자손 클래스의 인스턴스를 생성하면 해당 클래스의 멤버와 조상 클래스의 멤버가 합쳐진 하나의 인스턴스가 형성된다.

그렇기 때문에 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다.

주의할 점
> 조상 클래스 멤버의 초기화 작업이 수행되어야 한다. ( 자손 클래스의 초기화 작업에 사용될 수 있음 )

----
</details>

<details>
<summary>
import 문에 대해 설명
</summary>

----

소스 코드를 작성할 때 다른 패키지의 클래스를 사용하려면 **패키지명이 포함된 클래스 이름**을 사용해야 한다.

import 문을 사용하면 이러한 수고를 덜어줄 수 있으며 

- import 패키지명.클래스명
- import 패키지명

과 같은 형태로 사용한다.

또한 import 패키지명.* 과 같은 형태로 자주 사용하는 것을 볼 수 있는데 이는 지정된 패키지의 모든 클래스를 패키지명 없이 사용할 수 있으며 실행 시 성능 차이는 없다.

하지만 이와 같이 선언하면 import 하는 패키지의 수가 많을 경우 어느 클래스가 어느 패키지에 속하는지 구별하기 어렵다는 단점을 가지고 있다.

----
</details>

<details>
<summary>
static import 문에 대해 설명
</summary>

----

> static 멤버를 호출할 때 사용

ex)

````java
import static java.lang.Math.*;
import static java.lang.System.out;
class Ex{
    public static void main(String[] args) {
        System.out.println(random()); // Math.random()
        out.println();
    }
}
````

특정 클래스의 static 멤버를 자주 사용할 때 편리하다.

----
</details>

<details>
<summary>
</summary>

----



----
</details>







---
참고자료 : Java 의 정석 