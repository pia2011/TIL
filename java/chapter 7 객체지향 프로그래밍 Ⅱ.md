# 1. 상속

## 상속의 정의와 장점

상속의 정의
> 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

상속의 장점
> 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고, 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경에 매우 용이하다.

- 코드 재사용성을 높임
- 코드의 중복을 제거하여 생산성과 유지보수에 크게 기여함



![image](https://user-images.githubusercontent.com/53935439/208241149-0a517d72-4f56-4f4f-ae2f-42d6ac349afd.png)

조상 클래스
>상속해주는 클래스
- 부모 클래스
- 상위 클래스
- 기반 클래스

자손 클래스
>상속 받는 클래스
- 자식 클래스
- 하위 클래스
- 파생된 클래스

상속관계를 그림으로 표현한 것을 "상속계층도"라고하며 아래와 같이 표현한다.

![image](https://user-images.githubusercontent.com/53935439/208241523-d7140967-e027-432e-b727-b282fca8b4c6.png)

상속 관계의 특징은 아래와 같다.
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

그렇다면 만약 자손 클래스의 인스턴스를 생성하면 어떻게 될까? 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성된다. 
때문에 조상 클래스의 인스턴스를 생성하지 않고도 조상 클래스의 멤버들을 사용할 수 있다.

> 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

## 클래스간의 관계

상속 이외에도 클래스를 재사용하는 방법이 있는데 그것은 바로 클래스간에 포함 관계를 맺어주는 것이다.
클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

```java
class Circle{
    Point c = new Point();
    int r;
}
```

이런식으로 클래스를 멤버변수로 선언하여 포함관계를 맺어주면 작성하는 것도 쉽고 간결해서 이해하기 쉽다.
또한 단위클래스 별로 코드가 작게 나뉘에 작성되어 있기 때문에 코드를 관리하는데도 수월하다.

## 클래스간의 관계 결정하기

클래스를 작성하는데 있어서 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 결정하는 것은 때떄로 혼돈스러울 수 있다.

이럴 때는 아래와 같이 문장을 만들어 보면 클래스 간의 관계가 보다 명확해 진다.

상속관계
> Circle은 Point이다

포함관계
> Circle은 Point를 가지고 있다.

예를 들어 도형을 의미하는 Shape 클래스를 정의하고 Circle 클래스와 관계를 맺어준다면
> 원은 도형이다 (O) 원은 도형을 가지고 있다 (X)

라는 의미가 좀 더 자연스러울 것이다.

## 단일 상속

다른 객체지향언어와 다르게 자바에서는 오직 단일 상속만을 허용한다. 때문에 둘 이상의 클래스로부터 상속을 받을 수 없다.

다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 갖을 수는 있지만 아래와 같은 단점들이 있다.

- 클래스간의 관계가 매우 복잡해짐
- 서로 다른 클래스로부터 상속 받은 멤버의 이름이 같을 경우 구분할 수 있는 방법이 없음

때문에 클래스간의 관계를 보다 명확히 하고 코드를 더욱 신뢰할 수 있게 만들어주기 위해 단일 상속만을 허용한다.



## Object 클래스

Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스이다. 다른 클래스로부터 상속 받지 않는 모든 클래스는
컴파일러가 자동으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.

그렇기 떄문에 모든 클래스에서는 Object 클래스에 정의된 멤버들을 사용할 수 있는데
우리가 toString(), equals() 같은 메서드를 따로 정의하지 않고도 사용할 수 있었던 이유가 바로 이것이다.

# 2. 오버라이딩

## 오버라이딩이란

>조상 클래스로부터 상속 받은 메서드의 내용을 변경하는 것

## 오러라이딩의 조건

자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야한다.
- 매개변수가 같아야한다.
- 반환타입이 같아야한다.

즉, 한마디로 요약하자면 선언부가 서로 일치해야한다.

다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

조상 클래스의 메서드를 오버라이딩 할 때 주의사항
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
- 인스턴스 메서드를 static 메서드 또는 그 반대로 변경할 수 없다.

## super

> 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수

멤버 변수와 지역 변수의 이름이 같을 때, this를 통해 구분했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 
super를 붙여서 구분할 수 있다.

```java
class Parent{
    int x = 20;
}
class Child extends Parent{
    int x = 10;
    void method(){
        System.out.println(this.x); // 10
        System.out.prinltn(super.x); // 20
    }
}
class Ex{
    public static void main(String[] args) {
        Child c = new Child();
        c.method();
        
        /*
         * 10
         * 20
         * */
    }
}
```

## super() - 조상 클래스의 생성자

this()와 마찬가지로 super() 역시 생성자이다. this()의 경우 같은 클래스의 다른 생성자를 호출하는데 사용되지만

super()는
> 조상 클래스의 생성자를 호출하는데 사용된다.

자손 클래스의 인스턴스를 생성하면 자손 멤버와 조상 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 이 때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 
자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.

**생성자의 첫 줄에서 조상 클래스의 생성자를 호출**해야 하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 먼저 조상 클래스 멤버들이 초기화되어 있어야 하기 때문이다.

이와 같은 조상 클래스 생성자의 호출은 클래스의 상속관계를 거슬러 올라가면서 계속 반복되며 Object 클래스의 생성자까지 가서야 끝이난다.

그래서 Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 한다.

그렇지 않으면 컴파일러는 생성자의 첫 줄에 super(); 를 자동으로 추가할 것이다.

# 3. package와 import 

## 패키지

> 클래스의 묶음

서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.


## import 문

소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야된다.

하지만 매번 그렇게 작성하는 것은 불편하다..

> 클래스의 코드를 작성하기 전에 import 문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스 이름에서 패키지 명은 생략할 수 있다.

## import 문의 선언

- import 패키지명.클래스명
- import 패키지명

하나 더 알아두어야 할 것은 import 패키지명.* 을 하는 경우를 흔히 볼 수 있는데, 이는 해당 패키지에서 일치하는 수고를 덜어주며 
> 실행 시 성능차이는 전혀 없다


## static import 문

> static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

특정 클래스의 static 멤버를 자주 사용할 때 편리하며 코드도 간결해 진다.

# 4. 제어자 ( modifier )

## 제어자란?

제어자는 
> 클래스, 변수 또는 메서드의 선언부와 함께 사용되어 부가적인 의미를 부여한다.

제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.
- 접근 제어자
  - public, protected, default, private
- 그외
  - static, final, abstract, native, transient, synchronized, volatile, strictfp

주로 클래스나 멤버변수, 메서드에 사용되며 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

단, 접근제어자의 경우 하나만 선택가능

## static - 클래스의, 공통적인

static 은 멤버 변수, 메서드 그리고 초기화 블럭에서 사용되며, 이들은 클래스에 관계된 것이기 때문에 
> 인스턴스를 생성하지 않고도 사용할 수 있다.

인스턴스 메서드와 static 메서드의 근본적인 차이는 인스턴스 멤버를 사용하는가의 여부에 있다.
따라서 인스턴스 멤버를 사용하지 않는 메서드는 static 을 붙여서 static 메서드로 선언하는 것이 좋은데 이유는 
> 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 빠르다.

```java
class Ex{
    static int x = 0;
    static {
        // static 변수의 복잡한 초기화 수행
    }
    static int max(int a, int b){
        return a > b ? a : b;
    }
}
```

## final - 마지막의, 변경될 수 없는


변수에 사용되면 값을 변경할 수 없는 상수가 되며
메서드에 사용되면 오버라이딩을 할 수 없게 되고
클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

> 즉, 변경될 수 없어진다.

```java
final class Ex { // 자손 클래스 생성 불가능
    final int MAX_VALUE = 10; // 값 변경 불가능
    final void getMaxSize(){ // 오버라이딩 불가능
        return MAX_VALUE;
    }
}
```

## abstract - 추상의, 미완성의

## 접근 제어자

# 5. 다형성

# 6. 추상 클래스

# 7. 인터페이스

# 8. 내부 클래스 (inner class)