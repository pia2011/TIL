# 프로세스의 개요

운영체제에서 프로세스는 하나의 작업 단위이다. 프로그램을 실행하면 그 프로그램은 프로세스가 된다. 

## 프로세스의 개념

### 프로세스와 프로그램과의 차이

* 프로그램 : 저장장치에 저장되어 있는 정적인 상태
* 프로세스 : 실행을 위해 메모리에 올라온 동적인 상태

### 프로그램에서 프로세스로의 전환

프로세스는 컴퓨터 시스템의 작원 단위로 테스크라고도 부른다. 시분할 방식 시스템에서
프로그램이 프로세스로 전환되는 순서는 다음과 같다.

1. 운영체제가 프로그램을 메모리의 적당한 위치로 가져온다.
2. 작업 지시서에 해당하는 프로세스 제어 블록(PCB)을 만든다.

```
프로세스 제어 플록에 있는 다양한 정보 중 대표적인 세 가지는 다음과 같다.
- 프로세스 구분자 : 메모리에 여러 프로세스를 구분할 구분자
- 메모리 관련 정보 : 프로세스의 메모리 위치 정보
- 각종 중간값 : 시분할 시스템에서 필요한 값, 어디까지 처리 되었는지 표시하는 것과 유사 
```

PCB는 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어 진다.
그리고 프로세스가 종료되면, 프로세스가 메모리에서 삭제되고 프로세스 제어 블록 또한 폐기 된다. 

정리해서 말하자면 프로그램이 프로세스가 되었다는 것은 운영체제로 부터 PCB를 얻는다는 말이고, 
프로그램이 종료되었따는 것은 해당 PCB가 폐기 되었다는 말이다.

하나 알아두어야 할 것은 운영체제 또한 프로그램이기 때문에 프로세스 형태로 실행되어야 한다. 따라서
컴퓨터에는 일반 사용자의 프로세스와 운영체제의 커널 프로세스가 섞여서 실행된다.

## 프로세스의 상태


일괄 작업 시스템의 경우 프로세스가 생성된 이후 CPU를 얻어 실행되고 작업을 마치면 종료된다. 

하지만 시분할 시스템에서의 프로세스는 그와 다르게 좀 더 복잡하다. CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스에
CPU를 넘겨주는 일이 빈번하기 떄문이다.

### 프로세스의 네 가지 상태


![image](https://user-images.githubusercontent.com/53935439/154342064-7ce7b344-e509-4252-9ae6-f3b49b443525.png)

프로세스는 다음의 네가지 상태를 갖는다.
* 생성 상태 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태(PCB 생성)
* 준비 상태 : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
* 실행 상태 : CPU를 얻어 실제 작업을 실행하는 상태
* 완료 상태 : 주어진 시간 동안 작업을 마친 상태(PCB 사라짐)


준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케쥴러가 담당한다. 스케쥴러는 준비 상태의 프로세스 중 하나를 골라
실행 상태로 바꾸는데 이 작업을 디스패치라고 부르며, 스케쥴러는 프로세스의 모든 상태에 관여하며 모든 프로세스의 작업이 원만하게 이루어 지도록 관리한다.


### 프로세스의 다섯 가지 상태

프로세스는 생성, 준비, 실행, 완료의 다섯가지 상태만으로 작업을 진행하는데 큰 문제가 없다. 하지만 오늘날의 운영체제의 효율성을 고려하여 
한가지 상태를 더 만들었다. 


이유는 다음과 같다. 인터럽트 시스템에서 프로세스가 입출력을 요구하면 CPU가 직접 데이터를 가져오는 것이 아니라 입출력 관리자에게 명령을 내리게 되는데
이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없다. 따라서 CPU도 아무 작업을 하지 않고 기다리게 되어 효율성이 떨어진다.

이것을 해결하기 위해 하나의 상태(대기 상태)를 더 만들어서 입출력을 요청한 프로세스를 대기 상태로 옮긴다. 이렇게 되면 시스템 입장에서는 
준비 상태에 있는 프로세스 중 하나를 가져다가 실행 상태로 만들기 때문에 효율성이 높아진다.

# ![프로세스의 네 가지 상태](https://user-images.githubusercontent.com/53935439/154337431-c1b04edf-d35e-4b67-b4ea-57931e4250a5.PNG)

대기 상태의 프로세스는 요청한 입출력이 완료되고 다시 입출력 관리자로부터 인터럽트를 받는다. 이후에 바로 실행 상태로 돌리는 것이 아니라
준비 상태로 돌아가서 자기 차례를 기다리게 된다.

```
두 프로세스의 상태를 변화시켜야 하는것은 복잡한 일이다..
```

다시 다섯 가지 상태를 정리해 보자면

* 생성 상태 : 프로그램이 메모리에 올라오고 OS로부터 PCB를 할당 받은 상태
* 준비 상태 : 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태
* 실행 상태 : 프로세스가 CPU를 할당 받아 실행되는 상태 by CPU 스케쥴러
* 대기 상태 : 실행 상태에 있는 프로세스가 입출력을 요청하면 완료될 때까지 대기하는 상태 for 작업의 효율
* 완료 상태 : 프로세스가 종료되는 상태 (PCB 폐기)

### 휴식 상태와 보류 상태

대부분의 프로세스는 앞서 살펴 보았듯이 생성, 준비, 실행, 대기, 완료의 상태로 운영되고 이 다섯가지 상태를 
활성 상태라고 한다. 여기에 더해 두 가지 특별한 상태가 더 존재한다.

* 휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태 (ex 유닉스 ctrl+Z)
* 보류 상태 : 프로세스가 메모리에서 잠시 쫓겨난 상태

보류 상태는 다음과 같은 경우에 해당된다.

* 프로그램에 오류가 있어서 실행을 미루어야 할 때
* 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
* 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단 될 때
* 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
* 입출력을 기다리는 프로세스의 입출력이 계속 작업 될 때

이 밖에도 보류 상태에 들어가는 여러가지 이유가 존재 하는데, 
대부분이 컴퓨터의 성능을 떨어뜨리거나 실행을 미루어도 큰 지장이 없는 프로세스이다. 


![image](https://user-images.githubusercontent.com/53935439/154341294-2dfc8b2c-dc65-4072-a2dc-7a9f77f26067.png)

보류 상태에 들어간 프로세스는 스왑 영역에 보관된다. 보류 상태는 보류 대기 상태와 보류 준비 상태로 다시 나누어 진다.

# 프로세스 제어 블록과 문맥 교환

## 프로세스 제어 블록

PCB는 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조로 TCB(Task Control Block)라고도 한다. 

PCB의 구성은 다음과 같다.

![image](https://user-images.githubusercontent.com/53935439/154858274-fa3f9836-267d-4749-96f9-734940b2d745.png)

* 포인터 : 큐로 운영되는 PCB를 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 사용
* 프로세스 구분자 : OS내에 있는 여러 프로세스를 구별
* 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리킴

### 포인터의 역할

입출력이 완료되길 기다리는 프로세스는 대기 상태로 모이는데 시스템 내에는 다양한 종류의 입출력장치가 있기 때문에 대기 상태의 프로세스도 다양하다.

인터럽트가 들어올 때 한데 모여 있다면 모든 프로세스를 뒤져야 하므로 찾기 편하도록 동일한 입출력 큐에 모아 놓는다.

![image](https://user-images.githubusercontent.com/53935439/154858672-e6894c45-c6d8-464a-b523-6ccf05e60663.png)

## 문맥 교환

### 의미

문맥 교환은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이떄 PCB의 내용 또한 변경 되는데
나가는 프로세스에는 지금까지 작업했던 내용을 저장하고, 들어오는 프로세스의 내용으로 CPU가 다시 세팅된다. 이와 같이 두 PCB를 교환하는 작업을 문맥교환이라고 한다.

### 절차

![image](https://user-images.githubusercontent.com/53935439/154858856-a995b41c-e4ae-48d8-aaf6-125bd14fedfe.png)

문맥 교환이 일어나는 경우는 매우 다양한데, 일반적으로 타임아웃 시에 발생하며 인터럽트시에도 발생한다.

# 프로세스의 연산

