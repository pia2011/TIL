# 오브젝트와 의존관계

1장에서는 스프링이 관심을 갖는 대상인 오브젝트의 설계와 구현, 동작원리에 더 집중한다.
그렇게 하다보면 자연스럽게 스프링이 무엇인지도 이해될 것이다.

### 1.1 초난감 DAO


우리는 DAO로 원하는 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있다.

  ```
  DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 
  전담하도록 만든 오브젝트를 말한다.
  ```

그리고 그 정보를 저장할 때에는 자바빈 규약을 따라는 오브젝트를 이용하면 편리하다.

  ```
  자바빈(JavaBean)은 간단하게 빈이라고도 불리우며 다음의 두가지 관례를 따라 만들어진
  오브젝트를 가리킨다.
  - 디폴트 생성자(파라미터가 없는 생성자)를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을
  이용해서 오브젝트를 생성하기 때문이다.
  - 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 부르는데, 수정자 메소드(setter)와
  접근자 메소드(getter)를 이용해서 수정 또는 조회할 수 있다.
  ```

```
package springbook.user.domain;

public class User {
	String id;
	String name;
	String password;
	
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
}
```

JDBC를 이용하는 작업의 일반적인 순서는 다음과 같다.

1. DB연결을 위한 Connection을 가져온다.
2. SQL을 담은 Statement를 만든다.
3. 만들어진 Statement를 실행한다.
4. 조회의 경우 SQL쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
5. 작업 중에 생성된 리소스는 작업을 마친 후 반드시 닫아준다.
6. JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

```
package springbook.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import springbook.user.domain.User;

public class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring",
				"book");

		PreparedStatement ps = c.prepareStatement(
			"insert into users(id, name, password) values(?,?,?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

		ps.executeUpdate();

		ps.close();
		c.close();
	}


	public User get(String id) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring",
				"book");
		PreparedStatement ps = c
				.prepareStatement("select * from users where id = ?");
		ps.setString(1, id);

		ResultSet rs = ps.executeQuery();
		rs.next();
		User user = new User();
		user.setId(rs.getString("id"));
		user.setName(rs.getString("name"));
		user.setPassword(rs.getString("password"));

		rs.close();
		ps.close();
		c.close();

		return user;
	}

	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		UserDao dao = new UserDao();

		User user = new User();
		user.setId("whiteship");
		user.setName("백기선");
		user.setPassword("married");

		dao.add(user);
			
		System.out.println(user.getId() + " 등록 성공");
		
		User user2 = dao.get(user.getId());
		System.out.println(user2.getName());
		System.out.println(user2.getPassword());
			
		System.out.println(user2.getId() + " 조회 성공");
	}

}
```

위와 같이 만들어진 코드의 기능을 검증하고자 할 때 사용할 수 있는 가장 간단한 방법은 오브젝트 스스로 자신을
검증하게 만들어 주는 것이다. main() 메소드를 만들고 그 안에 오브젝트를 생성해서 getter와 setter 메소드를 이용해서
검증해 볼 수 있다. 물론 사용할 DB의 드라이버가 클래스패스에 있어야 하는 것도 잊지 말아야 한다.

이렇게 해서 사용자 정보의 등록과 조회가 되는 초간단 DAO와 테스트용 메소드까지 완성했다. 하지만 위 코드에서는 여러가지 문제가 있다.
그리고 앞으로 그 해결방법에 대해 학습할 것이다.

### 1.2 DAO의 분리

세상은 끊임없이 변하고, 사용자의 비지니스 프로세스와 그에 따른 요구사항 또한 끊임없이 바뀌고 발전한다. 또한 지금 사용하고 있는 기술도 시간이 지남에 따라 바뀌고 운영되는 환경도
변화한다. 그렇기에 개발자가 객체를 설계할 때 가장 염두해야할 것이 바로 미래의 변화에 어떻게 대비할 것인가이다. 그리하여 미래에 닥칠지 모르는 변경에 따른 
스트레스와 갈등을 최소화 할 수 있다.

객체지향 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은 번거로운 작업을 요구하는 이유는 객체 지향 기술 자체가 지니는 
변화에 효과적으로 대처할 수 있다는 기술적인 특징 덕분이다. 어떤 개발자는 단 몇 줄의 코드로 변경에 대처가 가능하지만 또 다른 개발자는 몇 시간이 걸려야만
동일한 기능을 변경할 수 있을지도 모른다. 이것은 분리와 확장을 고려한 설계의 차이에서 발생한다. 

프로그램의 기초 개념 중에 관심사의 분리라는게 있는데 이것을 객체지향에 적용해보면 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체 안으로 모이게 하여 
다른 관심들 끼리는 서로 영향을 주지 않도록 분리하는 것이다. 물론 하나로 뭉뚱그려서 모으는 편이 처음에는 쉽고 편하겠지만 언젠가는 분리의 필요성을 느낄떄가 찾아오게 된다.

```
	public void add(User user) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		// 1
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring",
				"book");

        // 2
		PreparedStatement ps = c.prepareStatement(
			"insert into users(id, name, password) values(?,?,?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

        // 3
		ps.executeUpdate();
		ps.close();
		c.close();
	}
```
위 코드에서만 적어도 3개의 관심사항을 발견할 수 있다.

* DB와 연결을 위해 커넥션을 가져오는 것
* DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
* 작업이 끝나고 사용한 리소스인 Statement와 Connection 오브젝트를 닫아주는 것

물론 get() 메소드에서 같은 코드를 반복해서 사용하는 것도 문제이다. 앞으로의 확장성을 생각한다면 이것은 바람직 하지 못한 코드이다. 먼저
중복된 커넥션을 가져오는 코드를 분리해 보겠다.

```
	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();

		PreparedStatement ps = c.prepareStatement(
			"insert into users(id, name, password) values(?,?,?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

		ps.executeUpdate();

		ps.close();
		c.close();
	}
	
		private Connection getConnection() throws ClassNotFoundException,
			SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring",
				"book");
		return c;
	}
```

이렇게 분리를 하게 될 경우 추후에 DB 연결과 관련된 변경이 일어날 경우 getConnection() 메소드의 코드만 수정하면 된다. 그리고 이렇게 
메소드로 중복된 코드를 뽑아내는 것을 리팩토링에서는 "메소드 추출" 기법이라고 부른다.

```
리팩토링은 기존 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 뜻한다. 이것을 통해 코드를 개선하면 이해하기 더 편해지고 
변화에 효율적으로 대응할 수 있다. 물론 적용하려면 '나쁜 냄새'를 맡는 충분한 학습과 훈련이 필요하다.
```

메소드 추출을 통해 변화에 좀 더 유연하게 대처할 수 있는 코드를 만들 수 있게 되었다면 상속을 통해서는 확장성 있는 코드를 만들 수 있다.

현재 getConnection()안에는 mysql의 커넥션을 가져오는 코드가 들어있는데 미래에도 계속 이렇게 한 가지의 DB를 사용하게 될지는 보장할 수 없다. 따라서
보다 확장성 있게끔 변경 가능성이 있는 메소드를 아래와 같이 추상 메소드로 만들어 놓는 다면, 필요에 따라서 상속받아 추상 메소드를 구현해서 확장할 수 있다.

```
public abstract class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
	    Connection c = getConnection(); // 팩토리 메서드 패턴을 이용
        // 코드 생략 : 데이터 엑세스 로직
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
	    Connection c = getConnection(); // 팩토리 메서드 패턴을 이용
		// 코드 생략 : 데이터 엑세스 로직
	}
	
	abstract protected Connection getConnection() throws ClassNotFoundException, SQLException ;

}

// 탬플릿 메서드 패턴
public class NUserDao extends UserDao {
	protected Connection getConnection() throws ClassNotFoundException,
			SQLException { // 팩토리 메서드
		// 코드 생략 : DB 연결 방법
	}
}

// 탬플릿 메서드 패턴
public class DUserDao extends UserDao {
	protected Connection getConnection() throws ClassNotFoundException,
			SQLException { // 팩토리 메서드 
		// 코드 생략 : DB 연결 방법
	}
}

```

### 탬플릿 메소드 패턴

이렇게 코드를 구성한다면 UserDao는 add()와 get()에만 관심을 담당하고 getConnection()은 상속받은 클래스가 담당하기 때문에
관심사가 분리되고 변경 작업이 한층 용이해 졌다. 다시말해 유연성 뿐만 아니라 확장성을 갖추었다.

이렇게 슈퍼클래스에서 기본적인 로직의 흐름을 만들고 기능의 일부를

* 추상 메소드 
* 오버라이딩이 가능한 protected 메소드

와 같이 만들어 준다면 서브 클래스에서 필요에 맞게 구현해서 사용할 수 있는데 이러한 방법을 디자인 패턴에서는 템플릿 메소드 패턴이라고 한다.
이 템플릿 메소드 패턴은 스프링에서 애용되는 디자인 패턴이다. 

### 팩토리 메소드 패턴

그리고 이렇게 서브 클래스에서 구체적인 "오브젝트 생성 방법"을 결정하게 하는 것을 팩토리 메소드 패턴이라고 한다.

위와 코드를 만들자고 할 때, 

* UserDao에 픽토리 메소드 패턴을 적용해서 getConnection()을 분리했다

라고 할 수 있다. 

```
이렇듯 디자인 패턴은 설계 전략이기도 하지만 굉장히 편리한 "커뮤니케이션 수단"이기도 하다.
간단히 패턴의 이름을 언급하는 것만으로도 설계의 의도와 해결책을 함께 설명할 수 있다.
```

```
팩토리 메소드 패턴은 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴이고 구조도 비슷하다.
그렇기에 좀 더 자세하게 설명하자면,

1. 슈퍼 클래스 코드에서 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용하고
2. 서브 클래스에서는 주로 인터페이스 타입으로 오브젝틀르 만들어 리턴해준다. 

요약을 하면 팩토리 메소드 패턴은 슈퍼클래스의 기본 코드에서 "오브잭트 생성 방법"을 독립시키는 방법이다.
```

하지만 위의 두 방법은 상속을 사용했다는 단점이 있다. 상속을 사용함에 있어서 발생하는 단점은 다음과 같다.

* 자바는 아쉽게도 클래스의 다중 상속을 허용하지 않는다. 그렇기 떄문에 만약 이미 다른 클래스를 상속하고 있다면 적용하기 힘들다.
* 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다. 그렇기 때문에 슈퍼 클래스의 변경이 있을 때 서브 클래스까지 영향을 미칠 수 있다.

## 1.3 DAO의 확장

 현재까지 구현해 놓은 코드를 살펴보면 두가지 관심사에 따라 분리되어 있다.

 * 데이터 엑세스 로직을 어떻게 만들 것인가
 * DB 연결 방법을 어떻게 할 것인가

이 두 개의 관심은 변화의 성격이 다르다. 변화의 성격이 다르다는 것은 변화의 이유와 시기, 주기 등이 다르다는 것이고 어느 한 곳의 코드 변경이 일어나더라도
다른 쪽 코드에는 변화가 없다. 즉, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경해서 쓸 수 있다. 하지만 분명 상속이라는 방법은 불편하다.

### 클래스의 분리

관심사가 다르고 변화의 성격이 다른 이 두가지를 좀 더 화끈하게 분리해보겠다.

아래 코드는 더 이상 상속을 사용해서 DB 커넥션 부분을 서브 클래스로 두는 것이 아닌 완전히 독립적인 클래스로 만든 코드이다.

```
package springbook.user.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import springbook.user.domain.User;

public abstract class UserDao {
	private SimpleConnectionMaker simpleConnectionMaker;
	
	public UserDao() {
		this.simpleConnectionMaker = new SimpleConnectionMaker();
	}

	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = this.simpleConnectionMaker.getConnection();

        // 코드 생략
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = this.simpleConnectionMaker.getConnection();
		PreparedStatement ps = c
				.prepareStatement("select * from users where id = ?");
		ps.setString(1, id);

		// 코드 생략
	}

	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		UserDao dao = new NUserDao();

		User user = new User();
		user.setId("whiteship");
		user.setName("백기선");
		user.setPassword("married");

		dao.add(user);
			
		System.out.println(user.getId() + " 등록 성공");
		
		User user2 = dao.get(user.getId());
		System.out.println(user2.getName());
		System.out.println(user2.getPassword());
			
		System.out.println(user2.getId() + " 조회 성공");
	}

}
```
```
package springbook.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class SimpleConnectionMaker {
	public Connection getConnection() throws ClassNotFoundException,
			SQLException {
		// 코드 생략
	}
}
```

기존 코드에 많은 수정이 발생했지만 기능에 변화를 주지 않는다. 화끈하게 분리를 했다. 
하지만 이제 더 이상 UserDao 클래스만 공급하고 DB 커넥션 기능을 확장해서 사용하게 할 수 없다.
